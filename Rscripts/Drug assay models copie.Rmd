---
title: "Drug assay models"
output: html_notebook
---

Here we want to quantify the effect of the drugs on each feature. To do that, we decided to build mixed linear models on the whole data (4 patients) for each drug and each feature. We also try simple linear models on the median of the 4 patients data. We then analyzed the results of these models by calculating scores of performances and visualize the best models according to these score to see if this choice of modeling is relevant. 

## Paths

**Copy Paste Here the path to your Drug-Assay-Study folder**

```{r}
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
```

```{r}
setwd(paste0(my_path,"/Rscripts"))
out_path=paste0(my_path,"/Drug assay csv")
```

## Libraries

```{r}
library(tidyverse)
library(tidyselect)
library(reshape2)
library(lme4)
#library(lmerTest)
library(ggplot2)
#library(r2glmm)
library(sjstats)
library(doSNOW)
library(parallel)
library(reticulate)
library(aomisc)
library(dplyr)
```

## Building model function

```{r}
# Function which attempts to build sigmoid models on the data
build.sigmoid.or.linear.model <- function(data, feature.name, drug.name, id="median"){
  # Building a linear or sigmoid model only when the response is not constant (we get an error message otherwise...)
  if (length(unique(data$value)) > 1){
    # Generate a sequence of intermediate doses
    intermediate_dose_0 <- lapply(1:(length(data$dose) - 1), function(i) (data$dose[i + 1] + data$dose[i])/2)
    intermediate_dose_1 <- lapply(1:(length(data$dose) - 1), function(i) data$dose[i]+(data$dose[i + 1] - data$dose[i])/3)
    intermediate_dose_2 <- lapply(1:(length(data$dose) - 1), function(i) data$dose[i]+2*(data$dose[i + 1] - data$dose[i])/3)
    intermediate_dose_3 <- lapply(1:(length(data$dose) - 1), function(i) data$dose[i]+(data$dose[i + 1] - data$dose[i])/4)
    intermediate_dose_4 <- lapply(1:(length(data$dose) - 1), function(i) data$dose[i]+3*(data$dose[i + 1] - data$dose[i])/4)
    intermediate_dose <- c(unlist(intermediate_dose_0), unlist(intermediate_dose_1), unlist(intermediate_dose_2), unlist(intermediate_dose_3), unlist(intermediate_dose_4), data$dose)
    # Interpolate the intermediate values at the intermediate doses
    interpolated_values_0 <- lapply(1:(length(data$value) - 1), function(i) (data$value[i + 1] + data$value[i])/2)
    interpolated_values_1 <- lapply(1:(length(data$value) - 1), function(i) data$value[i]+2*(data$value[i + 1] - data$value[i])/100)
    interpolated_values_2 <- lapply(1:(length(data$value) - 1), function(i) data$value[i]+98*(data$value[i + 1] - data$value[i])/100)
    interpolated_values_3 <- lapply(1:(length(data$value) - 1), function(i) data$value[i]+(data$value[i + 1] - data$value[i])/100)
    interpolated_values_4 <- lapply(1:(length(data$value) - 1), function(i) data$value[i]+99*(data$value[i + 1] - data$value[i])/100)
    interpolated_values <- c(unlist(interpolated_values_0), unlist(interpolated_values_1), unlist(interpolated_values_2),unlist(interpolated_values_3), unlist(interpolated_values_4), data$value)
    # Create a data frame with the interpolated data
    interpolated_data <- data.frame(dose = intermediate_dose, value = interpolated_values)
    # Sort the interpolated data by dose
    interpolated_data <- interpolated_data[order(interpolated_data$dose), ]
    
    # Sigmoid function we want to try to fit
    sigmoid_model <- function(x, b, c, d, e) {
      c + (d - c) / (1 + exp(-b * (x - e)))
    }
    model <- NULL
    class <- NULL
    # Attempt to fit the sigmoid model using nls() and fall back to a linear model
    try_result <- tryCatch({
      #Initilize parameters
      gaps <- abs(diff(data$value))
      jump <- which.max(gaps)
      start_e=mean(c(data$dose[jump], data$dose[jump+1]))
      start_b=sign(data$value[jump+1]-data$value[jump])
      startp <- list(b=start_b, c=min(data$value), d=max(data$value), e=start_e)
      # Model fitting
      model <-nls(value ~ sigmoid_model(dose, b, c, d, e), data = interpolated_data, start=startp, algorithm = "port")
      class <- "sigmoid"
    }, error = function(e) {
      model<<-suppressMessages(lm(value ~ dose, data = data))
      class <<- "linear"
    })
    # Check if there was an error
    if (class=="sigmoid") {
      # Sigmoid model fitting was successful
      class <- "sigmoid"
      # Mean average pourcentage error
      coefs <- coef(model)
      preds <- sigmoid_model(data$dose, coefs[["b"]], coefs[["c"]], coefs[["d"]], coefs[["e"]])
      MAPE <- sum(abs((data$value-preds)/data$value)*100)/4
      scores <- list("MAPE"=MAPE)
    }
    if (class=="linear"){
      # Sigmoid model fitting was NOT successful
      coefs <- coef(model) %>% 
          setNames(c("Intercept", "Slope"))
      aic <- AIC(model)
      pval <- summary(model)$coefficients[, "Pr(>|t|)"][["dose"]]
      residuals <- residuals(model)
      rmse <- sqrt(mean(residuals^2))
      scores <- list("aic"=aic, "pval"=pval, "rmse"=rmse)
    }
  }else{
    # When there is only one value, the model is constant
    model <- list(unique(data$value))
    aic <- NA
    pval <- NA
    rmse <- NA
    scores <- list("aic"=aic, "pval"=pval, "rmse"=rmse)
    class <- "constant"
  }
  # Adding new linear model to models
  return(data.frame(feature = feature.name,
                     drug = drug.name,
                     ID=id,
                     model = I(list(model)),
                     scores = I(list(scores)),
                     class = class,
                     stringsAsFactors = FALSE))
}
```

## Individual models

Importing penalized preprocessed data with the different scales.

```{r}
# AllPenDoseresponse
load(paste0(out_path, "/all pen dose response with scales.rda"))
```

Function building a the mixed models for a given drug across the 720 features.

```{r}
build.individual.model <- function(drug.name, dataset){
  # Create an empty data frame to store the results
  models <- data.frame(stringsAsFactors = FALSE)
  
  for (feature.name in unique(dataset$feature)){
    # Subset of the dataset 
    Subset <- dataset %>% 
                  filter(feature == !!feature.name) %>%
                  filter(drug == !!drug.name)  %>%
                  dplyr::select(c("ID", "dose", "value"))
    for (id in unique(Subset$ID)){
      # Subset at the individual level
      subset <- Subset %>%
                  filter(ID==id) %>%
                  dplyr::select(c("ID", "dose", "value"))
      new_model <- build.sigmoid.or.linear.model(subset,feature.name, drug.name,id)
      # Adding new linear model to models
      models <- rbind(models,new_model)
    }
  }
  return(models)
}
```

**log10.individual.model :** dataframe containing all the informations about the mixed linear models that are built on each feature on a log10 scale of the concentrations.

```{r}
# Setting the dose values to their log10 transform
Doseresponse <- AllPenDoseresponse %>%
                  mutate(dose = log10_dose) %>%
                  filter(is.finite(dose))

# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create individual linear models on log10 scale
log10.individual.model = foreach(drug.name = unique(Doseresponse$drug), 
                                   .packages = c("tidyverse","lme4", "lmerTest","dplyr"),
                                   .combine = rbind) %dopar% build.individual.model(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(log10.individual.model, 
     file=paste0(out_path, "/log10 individual models.rda"))
```

**log10_1.individual.model :** dataframe containing all the informations about the mixed linear models that are built on each feature on a log10(x+1) scale of the concentrations.


```{r}
# Setting the dose values to their log10(x+1) transform
Doseresponse <- AllPenDoseresponse %>%
                  mutate(dose = log10_1_dose) %>%
                  filter(is.finite(dose))

# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create individual linear models on log10 scale
log10_1.individual.model = foreach(drug.name = unique(Doseresponse$drug), 
                                   .packages = c("tidyverse","lme4", "lmerTest", "dplyr"),
                                   .combine = rbind) %dopar% build.individual.model(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(log10_1.individual.model, 
     file=paste0(out_path, "/log10_1 individual models.rda"))
```

**pseudo_log10.individual.model :** dataframe containing all the informations about the mixed linear models that are built on each feature on a pseudo_log10 (=asinh(x/2)/log(10)) scale of the concentrations.

```{r}
# Setting the dose values to their pseudo log transform
Doseresponse <- AllPenDoseresponse %>%
                  mutate(dose = pseudo_log_dose) %>%
                  filter(is.finite(dose))

# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create linear mixed models on pseudo log scale
pseudo_log10.individual.model = foreach(drug.name = unique(Doseresponse$drug), 
                                   .packages = c("tidyverse","lme4", "lmerTest", "dplyr"),
                                   .combine = rbind) %dopar% build.individual.model(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(pseudo_log10.individual.model, 
     file=paste0(out_path, "/pseudo_log10 individual models.rda"))
```

## Linear models on medians

Importing penalized preprocessed data with the different scales.

```{r}
# MedianDoseresponse
load(paste0(out_path, "/median pen dose response with scales.rda"))
```

Function building a the linear models for a given drug across the 720 features.

```{r}
build.median.models <- function(drug.name, dataset){
  # Create an empty data frame to store the results
  models <- data.frame(stringsAsFactors = FALSE)
  
  # We look at each drug for a given feature
  for (feature.name in unique(dataset$feature)){
    # subset of the dataset 
    subset <- dataset %>% 
                  filter(feature == !!feature.name) %>%
                  filter(drug == !!drug.name)  %>%
                  mutate(value=median_value) %>%
                  dplyr::select(c("dose", "value")) %>%
                  distinct() %>%
                  suppressMessages()

    new_model <- build.sogmoid.or.linear.model(subset,feature.name, drug.name)
    # Adding new linear model to models
    models <- rbind(models,new_model)
  }
  return(models)
}
```

**log10.median.model :** dataframe containing all the information about the linear models that are built on each feature on a log10 scale of the concentrations.

```{r}
# Setting the dose values to their log10 transform
Doseresponse <- MedianDoseresponse %>%
                  mutate(dose = log10_dose) %>%
                  filter(is.finite(dose))
build.median.linear.models(drug.name, Doseresponse)
# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create linear mixed models on log10 scale
log10.median.model = foreach(drug.name = unique(Doseresponse$drug), 
                                   .packages = c("tidyverse","lme4", "lmerTest", "dplyr"),
                                   .combine = rbind) %dopar% build.median.models(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(log10.median.model, 
     file=paste0(out_path, "/log10 median models.rda"))
```

**log10_1.median.model :** dataframe containing all the information about the linear models that are built on each feature on a log10(x+1) scale of the concentrations.

```{r}
# Setting the dose values to their log10 transform
Doseresponse <- MedianDoseresponse %>%
                  mutate(dose = log10_1_dose) %>%
                  filter(is.finite(dose))

# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create linear mixed models on log10 scale
log10_1.median.model = foreach(drug.name = unique(Doseresponse$drug),
                                      .packages = c("tidyverse","lme4", "lmerTest", "dplyr"),
                                      .combine = rbind) %dopar% build.median.models(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(log10_1.median.model, 
     file=paste0(out_path, "/log10_1 median models.rda"))
```

**pseudo_log10.median.model :** dataframe containing all the information about the linear models that are built on each feature on a pseudo_log10 scale of the concentrations.

```{r}
# Setting the dose values to their log10 transform
Doseresponse <- MedianDoseresponse %>%
                  mutate(dose = pseudo_log_dose) %>%
                  filter(is.finite(dose))

# Set up parallel backend using doParallel
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)

# Create linear mixed models on log10 scale
pseudo_log10.median.model = foreach(drug.name = unique(Doseresponse$drug),
                                           .packages = c("tidyverse","lme4", "lmerTest", "dplyr"),
                                           .combine = rbind) %dopar% build.median.models(drug.name, Doseresponse)

# Close parallel backend
stopCluster(cl)

# Saving mixed models
save(pseudo_log10.median.model, 
     file=paste0(out_path, "/pseudo_log10 median models.rda"))
```

## Determining the most relevant scale and model fitting strategy

Loading the models (Necessary only if you haven't run all the code above).

```{r}
for (scale in c("pseudo_log10", "log10", "log10_1")){
  load(paste(out_path, "/", scale, " median models.rda", sep=""))
  load(paste(out_path, "/", scale, " individual models.rda", sep=""))
}
```

Looking at how many models are above the pvalue threshold of 0.05

```{r}
print("-------------------------------------------------------")
print("Number of features that are represented by models with pval >= 0.5")
print("-------------------------------------------------------")
indiv.total <- dim(log10.individual.linear.model)[1]
print(paste0("Total number of drugxfeatures combinations (indivual models): ", 
             indiv.total))
print(paste("pseudo_log10.individual.linear.model : ",
             dim(pseudo_log10.individual.linear.model[pseudo_log10.individual.linear.model$pval >=0.5,])[1], " (",
             dim(pseudo_log10.individual.linear.model[pseudo_log10.individual.linear.model$pval >=0.5,])[1]/indiv.total,"%)", 
             sep=""))
print(paste("log10.linear.individual.model : ",
             dim(log10.individual.linear.model[log10.individual.linear.model$pval >=0.5,])[1]," (",
             dim(log10.individual.linear.model[log10.individual.linear.model$pval >=0.5,])[1]/indiv.total,"%)", 
             sep=""))
print(paste("log10_1.individual.linear.model : ",
             dim(log10_1.individual.linear.model[log10_1.individual.linear.model$pval >=0.5,])[1]," (",
             dim(log10_1.individual.linear.model[log10_1.individual.linear.model$pval >=0.5,])[1]/indiv.total,"%)", 
             sep=""))
print("-------------------------------------------------------")
median.total <- dim(log10.median.linear.model)[1]
print(paste("Total number of drugxfeatures combinations (median models): ", 
             median.total))
print(paste("pseudo_log10.median.linear.model : ",
             dim(pseudo_log10.median.linear.model[pseudo_log10.median.linear.model$pval >=0.5,])[1]," (",
             dim(pseudo_log10.median.linear.model[pseudo_log10.median.linear.model$pval >=0.5,])[1]/median.total,"%)", 
             sep=""))
print(paste("log10.median.linear.model : ",
             dim(log10.median.linear.model[log10.median.linear.model$pval >=0.5,])[1]," (",
             dim(log10.median.linear.model[log10.median.linear.model$pval >=0.5,])[1]/median.total,"%)", 
             sep=""))
print(paste0("log10_1.median.linear.model : ",
             dim(log10_1.median.linear.model[log10_1.median.linear.model$pval >=0.5,])[1]," (",
             dim(log10_1.median.linear.model[log10_1.median.linear.model$pval >=0.5,])[1]/median.total,"%)", 
             sep=""))
```

## Linear models analysis

Loading pseudo_log10.median.linear.model and pseudo_log10.linear.mixed.model (Necessary only if you haven't run all the code above).

```{r}
load(paste0(out_path, "/pseudo_log10 median linear models.rda"))
load(paste0(out_path, "/pseudo_log10 individual linear models.rda"))
```

To see which models are the best fit, we decided to rank them based on different scores which are all going to be store in the variable **model.scores**.

```{r}
# Dataframe containing : rmse, slope, absolute value of the slope and the score -log10(pval)*|slope|
median.model.scores <- pseudo_log10.median.linear.model %>%
                          select(-model) %>%
                          mutate(abs.slope = abs(slope),
                                 score = -log(pval, base=10)*abs.slope) %>%
                          distinct(feature, drug, rmse, abs.slope, score, .keep_all = TRUE) %>%
                          arrange(desc(score))

# Dataframe containing : rmse, slope, absolute value of the slope and the score -log10(pval)*|slope|
individual.model.scores <- pseudo_log10.individual.linear.model %>%
                          select(-model) %>%
                          mutate(abs.slope = abs(slope),
                                 score = -log(pval, base=10)*abs.slope) %>%
                          distinct(ID, feature, drug, rmse, abs.slope, score, .keep_all = TRUE) %>%
                          arrange(desc(score))
```

Saving model.scores

```{r}
save(median.model.scores, file=paste0(out_path, "/median model scores.rda"))
save(individual.model.scores, file=paste0(out_path, "/individual model scores.rda"))
```

## Visualization

Importing preprocessed data.

```{r}
# AllPenDoseresponse
load(paste0(out_path, "/all pen dose response with scales.rda"))
# MedianDoseresponse
load(paste0(out_path, "/median pen dose response with scales.rda"))
```

Plotting the best models according to mixed.model.scores

```{r}
load(paste0(out_path, "/individual model scores.rda"))
individual.model.scores
```

Individual models plot

```{r}
# Selecting a specific model
target_feature <- "intMCs_CREB_IFNa"
target_drug <- "Pravastatin"
target_models <- subset(pseudo_log10.individual.linear.model,
                    feature == target_feature & drug == target_drug,
                    select = c("ID", "model"))

# Setting the dose values to their pseudo log transform
Doseresponse <- AllPenDoseresponse %>%
                  mutate(dose = pseudo_log_dose,
                         ID = as.factor(ID)) %>%
                  filter(is.finite(dose))

# Coefficients of the selected model
model_coefs <- target_models %>%
                  mutate(Slope = sapply(model, function(x) coef(x)["dose"]),
                  Intercept = sapply(model, function(x) coef(x)["(Intercept)"]),
                  ID = as.factor(ID))

# Subset of the data for the chosen feature and drug
data <- Doseresponse %>% 
            filter(feature == target_feature) %>%
            filter(drug == target_drug) %>%
            select(ID, dose, value)

data_rani <- left_join(data, model_coefs, by = "ID")

# Plot
ggplot(data = data_rani,
       mapping = aes(x = dose, 
                     y = value, 
                     colour = ID)) +
  geom_point(na.rm = T, alpha = 0.5) +
  geom_abline(aes(intercept = Intercept, 
                  slope = Slope,
                  colour = ID),
              size = 1.5) +
  theme(legend.position = "top") +
  xlab(target_feature) +
  ylab(target_drug)
```

Plotting the best models according to model.scores

```{r}
load(paste0(out_path, "/median model scores.rda"))
median.model.scores
```

Linear models on median plot

```{r}
# Selecting a specific model
target_feature <- "CD8Tnaive_IkB_IFNa"
target_drug <- "Pravastatin"
target_model <- pseudo_log10.median.linear.model$model[pseudo_log10.median.linear.model$feature == target_feature &
                                                        pseudo_log10.median.linear.model$drug == target_drug][[1]]

# Setting the dose values to their pseudo log transform
Doseresponse <- AllPenDoseresponse %>%
                  mutate(dose = pseudo_log_dose,
                         ID = as.factor(ID)) %>%
                  filter(is.finite(dose))

# Coefficients of the selected model
model_coefs <- coef(target_model) %>%
                  as.data.frame() %>%
                  t() %>%
                  `colnames<-`(c("Intercept", "Slope"))

# Subset of the data for the chosen feature and drug
data <- Doseresponse %>% 
            filter(feature == target_feature) %>%
            filter(drug == target_drug) %>%
            select(ID, dose, value)

data_rani <- merge(data, model_coefs)

ggplot(data_rani, aes(x=dose, y=value, group=dose)) +
  geom_boxplot() +
  geom_abline(aes(intercept = Intercept, 
                  slope = Slope),
              size = 1.) +
  theme(legend.position = "top") +
  xlab(target_feature) +
  ylab(target_drug)
```
**Conclusion :** The best models seem to fit the data very well. We will always be able to come back to this R script for improvements. We can continue our analysis being confident that the slopes of these mixed and linear models are good estimators of the effect of the drugs on the features.
