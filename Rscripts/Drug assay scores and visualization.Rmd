---
title: "Drug assay scores and visualization"
output: html_notebook
---

## Paths

Here we set all the necessary paths to import and save data and plots.

```{r}
current_dir <- getwd()
my_path <- sub("/[^/]+$", "", current_dir)
setwd(paste0(my_path,"/Rscripts"))
OOL_path=paste0(my_path,"/Onset of Labor data")
drug_assay_path=paste0(my_path,"/Drug assay data")
plot_path=paste0(my_path, "/Plots/Drug sigmoids vs OOL features")
```

Creating directories for the outputs

```{r}
if(!file.exists(plot_path)){dir.create(plot_path, recursive = TRUE)}
```

## Libraries

```{r}
library(tidyverse)
library(tidyselect)
library(reshape2)
library(dplyr)
library(pheatmap)
library(RColorBrewer)
library(viridis)
library(paletteer)
library(tidyr)
library(janitor)
library(utils)
library(ggplot2)
library(r2glmm)
library(sjstats)
library(gridExtra)
library(grid)
```

## Loading Data and Models

**OOL data and models**

```{r}
# df_models
load(paste0(OOL_path, "/Curve classification/all_pen_model_curves_cytof.rda"))

# curve.classification
curve.classification <- read.csv(paste0(OOL_path, "/Curve classification/all_pen_classification_curves_cytof.csv"))

# feature.index (only keeping features that have been selected in the model)
load(paste0(OOL_path, "/Prediction model/feature_index.rda"))

# penalized dataset with outcomes (DOS) ante partum
OOL_data <- read.csv(paste0(OOL_path, "/Preprocessed Data/immunome_noEGA_DOS_pen_OOL.csv")) %>%
            # We are interested in DOS <=0
            dplyr::filter(DOS <= 0)
  
# outcomes
DOS <- OOL_data$DOS
```

**Drug Assay data and models**

```{r}
# median.sigmoid.scores
load(paste0(drug_assay_path, "/Sigmoid functions/median sigmoids scores.rda"))
# individual.sigmoid.scores
load(paste0(drug_assay_path, "/Sigmoid functions/individual sigmoids scores.rda"))
# hand.log10_1.median.model
load(paste0(drug_assay_path, "/Sigmoid functions/log10_1 hand median models.rda"))
# hand.log10_1.individual.model
load(paste0(drug_assay_path, "/Sigmoid functions/log10_1 hand individual models.rda"))
# MedianDoseresponse
load(paste0(drug_assay_path, "/Preprocessed Data/median pen dose response with scales.rda"))
# AllPenDoseresponse
load(paste0(drug_assay_path, "/Preprocessed Data/all pen dose response with scales.rda"))
# drug.effect.tensors
load(paste0(drug_assay_path, "/Drug effect tensors/drug effect tensors.rda"))
```

## Scores

Here we want to compare the drug effect on each feature to the "normal" behavior of the feature modeled in OOL study.

### Auxiliary score functions and variables

**rescaled.drug.effect.tensors**

Here we rescale the drug effect tensor so that a small effect in a feature that change only very slightly during pregnancy is considered as important as a large effect on a feature taking a larger range of values during pregnancy. We rescaled the tensor by dividing each feature by the 95%-tile - 5%-tile (not to take into account the occasional outlier) of the values taken by the feature in the OOL dataset.

```{r}
# Creating a dataframe with the range of the values taken by each feature in OOL dataset
range_feature <- dplyr::select(OOL_data, -ID) %>% 
                  pivot_longer(cols=colnames(dplyr::select(OOL_data, -ID)), names_to="feature", values_to="value") %>%
                  group_by(feature) %>%
                  summarize(range=quantile(value, probs=0.95, na.rm=T)-quantile(value, probs=0.05, na.rm=T)) %>%
                  # We penalize all features with range values under 0.1
                  dplyr::mutate(range=ifelse(range < 0.1, Inf, range)) %>%
                  arrange(range) %>%
                  column_to_rownames("feature")

# Rescaling the features one by one in each tensor by dividing their tensor value by their range
rescaled.drug.effect.tensors <- drug.effect.tensors
for (centroid in names(rescaled.drug.effect.tensors)){
  for (c_k in seq(length(rescaled.drug.effect.tensors[[centroid]]))){
    for (feature in rownames(rescaled.drug.effect.tensors[[centroid]][[c_k]])){
      rescaled.drug.effect.tensors[[centroid]][[c_k]][feature,] <-
        rescaled.drug.effect.tensors[[centroid]][[c_k]][feature,]/range_feature[feature,]
    }
  }
}
```

**feature.normal.behavior.at.TTL**

```{r}
# Function which returns
# 1 if the model (of the OOL feature) is increasing at TTL
# -1 if the model (of the OOL feature) is decreasing at TTL
# NA if the behavior of the feature is inconclusive (missing model or too weak slope)
# based on the model (contained in a list) itself and its p-value

feature.normal.behavior.at.TTL <- function(model, pval, slope.threshold, pval.threshold, TTL){
  if (length(pval) == 0 || is.na(pval) || pval > pval.threshold || length(model) == 0){
    return(NA)
  }
  else{
    # Here we focus un the derivative around 0 to estimate the behavior of the feature
    model <- model[[1]]
    quadratic <- (length(model) == 3)

    # Derivative of the model at TTL
    # for quadratic model
    if (quadratic){
      deriv <- 2*model[['DOS2']]*TTL + model[['DOS']]
    } 
    # for linear model
    else{
      deriv <- model[['DOS']]
    }
    
    # Returning effect coefficient
    if (abs(deriv) > slope.threshold){
      return(deriv/abs(deriv))
    }
    else{
      return(NA)
    }
  }
}
```

**create.drug.effect.data.frame**

```{r}
# Function which creates a dataframe with 
# 1 when the drug is affecting the feature the opposite direction of its normal behavior at TTL
# -1 when the drug is affecting the feature the same direction of its normal behavior at TTL
# 0 when the effect of the drug is null
# NA when behavior of the feature is null or hard to estimate (high p-value) or if we miss data in the drug assay study
# This function is helpful to create the heatmaps in the visualization section

create.drug.effect.data.frame <- function(drug.name,
                                          c_k,
                                          centroid,
                                          normal.behavior.pval.threshold, 
                                          normal.behavior.slope.threshold, 
                                          TTL){
  
  # Dataframe feature ~ stimulation containing the final effect on a drug on each feature under each stimulation
  drug.effect.dataframe <- rescaled.drug.effect.tensors[[centroid]][[c_k]] %>%
                        dplyr::select(drug.name) %>%
                        rename("drug.behavior"=drug.name) %>%
                        rownames_to_column("feature") %>%
                        dplyr::mutate(drug.behavior = ifelse(is.na(drug.behavior), 0., drug.behavior),
                                      population = str_extract(feature, "^[^_]+"),
                                      reagent_stim = str_extract(feature, "(?<=_).*$")) %>%
                        dplyr::select(population, drug.behavior, reagent_stim) %>%
                        pivot_wider(names_from = reagent_stim, values_from = drug.behavior)
  
  # Concatenation of all information on the feature models + normal.behavior = +1, -1 or NA
  model.info <- merge(df_models, curve.classification, by.x = "feature", by.y = "cytof") %>%
                rowwise() %>%
                dplyr::mutate(normal.behavior = feature.normal.behavior.at.TTL(model,
                                                                               pval, 
                                                                               normal.behavior.slope.threshold,
                                                                               normal.behavior.pval.threshold,
                                                                               TTL))
  # Dataframe feature ~ stimulation containing the values of normal.behavior
  behavior.dataframe <- model.info %>%
                          dplyr::mutate(population = str_extract(feature, "^[^_]+"),
                                        reagent_stim = str_extract(feature, "(?<=_).*$")) %>%
                          dplyr::select(population, normal.behavior, reagent_stim) %>%
                          pivot_wider(names_from = reagent_stim, values_from = normal.behavior) %>%
                          # removing features not measured in both studies (drugs and OOL)
                          # `STAT3_LPS`, `STAT5_LPS`, `STAT1_LPS`, `STAT6_LPS`, `STAT1_GMCSF`
                          # "STAT1_unstim"
                          dplyr::filter(population %in% drug.effect.dataframe$population) %>%
                          dplyr::select(one_of(colnames(drug.effect.dataframe)))

  # Dataframe feature ~ stimulation containing the product of behavior.matrix and drug.effect.matrix
  drug.final.effect.dataframe<- merge(pivot_longer(select(behavior.dataframe, 
                                                           one_of(colnames(drug.effect.dataframe))), 
                                                   cols = -population, 
                                                   names_to = "reagent_stim", 
                                                   values_to = "normal.behavior"),
                                      pivot_longer(select(drug.effect.dataframe,
                                                          one_of(colnames(behavior.dataframe))), 
                                                   cols = -population, 
                                                   names_to = "reagent_stim", 
                                                   values_to = "drug.behavior"),
                                      by = c("population", "reagent_stim")) %>%
                                rowwise() %>%
                                mutate(drug.final.effect = ifelse(is.na(normal.behavior) ||
                                                                    is.na(drug.behavior),
                                                                  NA,
                                                                  -normal.behavior*drug.behavior)) %>%
                                select(population, reagent_stim, drug.final.effect) %>%
                                pivot_wider(names_from = reagent_stim, values_from = drug.final.effect)

  return(drug.final.effect.dataframe)
}
```

### Features of interest

These are the features selected by our model.

**Top features from feature.index**

```{r}
# Top immunome features from the feature.index
# we associate a coeff +1 (increasing) or -1 (decreasing) to the features

# Timepoint of interest
TTL <- mean(-79, -81, -81, -70)

# Thresholds to calculate the normal behavior of a given feature
normal.behavior.slope.threshold <- 0.
normal.behavior.pval.threshold <- 10

# Info (model, pval, rmse, ...) of the models at the timepoint TTL
model.info <- merge(df_models, curve.classification, by.x = "feature", by.y = "cytof") %>%
              rowwise() %>%
              mutate(normal.behavior = feature.normal.behavior.at.TTL(model,
                                                                      pval, 
                                                                      normal.behavior.slope.threshold,
                                                                      normal.behavior.pval.threshold,
                                                                      TTL))
# List of the features and their behavior
top.feature.index <- feature.index %>%
                        filter(model_index > 0) %>%
                        left_join(model.info, by="feature") %>%
                        select(feature, normal.behavior) %>%
                        pull(normal.behavior) %>% 
                        setNames(pull(feature.index[(feature.index$model_index > 0) & !(is.na(feature.index$model_index)),], 
                                      feature)) %>%
                        as.list()
```

### Drugs ranking

Here we rank the drugs based on their effect on the chosen features of interest. We associate a positive score when the drug has an effect which is opposite to the "normal" behavior/ trend of the feature and negative when the effect of the drug is colinear to the "normal" feature behavior.

```{r}
# Models of interest
final.model <- hand.log10_1.individual.model

# Choosing features of interest
feature_choice <- "top_feature_index"
OOL_features <- top.feature.index
```

Calculation of the scores and ranking of the features.

**list.drug.ranking :** list of dataframes containing the name of the drugs and their score when loooking at its effects on patient 1, 2, 3, 4 and median effect.

```{r}
# This what one ranking dataframe look like
drug.ranking <- data.frame(drug = character(),
                           dose = numeric(),
                           score = numeric(),
                           stringsAsFactors = FALSE)

# We create one ranking dataframe per centroid
list.drug.ranking <- list("ID_median"=drug.ranking,
                          "ID_1"=drug.ranking,
                          "ID_2"=drug.ranking,
                          "ID_3"=drug.ranking,
                          "ID_4"=drug.ranking)


# Getting a normalized log transform of the feature index to be used as coefficient in the score
norm.log.feature.index <- feature.index %>%
                            dplyr::mutate(log.model_index = log10(1 + model_index),
                                          norm.log.model_index = log.model_index/sum(log.model_index, na.rm=TRUE)) %>%
                            dplyr::select(feature, norm.log.model_index) %>%
                            pull(norm.log.model_index) %>% 
                            setNames(pull(feature.index, feature)) %>%
                            as.list()

# Calculating the score for all the centroids
for (centroid in names(list.drug.ranking)){
  for (drug in colnames(rescaled.drug.effect.tensors[[1]][[1]])){
    for (c_k in seq(length(rescaled.drug.effect.tensors[[1]]))){
      score <- 0
      # We sum the scores over all the features for each drug
      for (feature in names(OOL_features)){
        # Getting the drug effect on the selected feature
        drug_effect <- rescaled.drug.effect.tensors[[centroid]][[c_k]][feature, drug]
        # Sometimes the feature we are interested in is not part of the drug assay study so we replace the drug effect by 0
        drug_effect <- ifelse(is.na(drug_effect), 0., drug_effect)
        # Adding the individual scores of the drug each feature 
        score <- score - drug_effect*OOL_features[[feature]]*norm.log.feature.index[[feature]]
      }
      # Adding the drug and its score to drug.ranking
      list.drug.ranking[[centroid]] <- rbind(list.drug.ranking[[centroid]],
                                             data.frame(drug=drug,
                                                        dose=10^(c_k-1),
                                                        score=score,
                                                        stringsAsFactors = FALSE))
    }
  }
  # Arranging the drugs to see the best drugs on top
  list.drug.ranking[[centroid]] <- list.drug.ranking[[centroid]] %>% arrange(desc(score))
}
list.drug.ranking
```
Comparison of the ranking with ranking from Computational discovery of therapeutic candidates for preventing preterm birth, Brian L. Le, Sota Iwatani, Ronald J. Wong, David K. Stevenson, and Marina Sirota.

```{r}
reference.ranking <- read.csv(paste0(drug_assay_path, "/Drug Assay Project Initial Data/reference_ranking.csv"), sep=";") %>% dplyr::mutate(old.rank = row_number())
new.ranking <- list.drug.ranking$ID_4 %>% group_by(drug) %>% summarise(median.score = median(score)) %>% dplyr::mutate(new.rank = row_number()) %>% right_join(reference.ranking, by="drug")
kendall_coef <- cor(new.ranking$old.rank, new.ranking$new.rank, method = "kendall")
print(kendall_coef)
#group_by(drug) %>% summarise(mean.score = mean(score)) %>% arange(desc(mean.score))...
```

## Visualization

### Models versus "normal" behavior

Auxiliary function to plot the individual sigmoids.

**sigmoid_function**

```{r}
sigmoid_function <- function(x, b, c, d, e) {
  return(c + (d - c) / (1 + exp(-b * (x - e))))
}
```

**plot_individual_sigmoids : ** creating one plot for individual models

```{r}
plot_individual_sigmoids <- function(target_feature, target_drug, model_list=hand.log10_1.individual.model){
  # Selecting a specific model
  target_models <- subset(model_list,
                      feature == target_feature & drug == target_drug)
  
  # Setting the dose values to their log10(x+1) transform
  data <- AllPenDoseresponse %>%
                    dplyr::mutate(dose = log10_1_dose,
                                  ID = as.factor(ID)) %>%
                    dplyr::filter(is.finite(dose),
                                  feature == target_feature,
                                  drug == target_drug) %>%
                    dplyr::select(ID, dose, value)
  
  # Dataframe containing the function values on [min(dose), max(dose)]
  X = seq(min(data$dose), max(data$dose), length.out=100)
  df_fun <- data.frame(x=rep(X, length(unique(target_models$ID))), fun = rep(as.factor(target_models$ID), each = 100))
  values <- c()
  for (id in target_models$ID){
    model=target_models[target_models$ID==id,]
    constant <-data[data$ID==id,]$value[1]
    for (x in X){
        values <- c(values, sigmoid_function(x, model$b, model$c, model$d, model$e))
    }
  }
  df_fun <- cbind(df_fun, values)
  
  # Plot
  plot <- ggplot()
  for (id in target_models$ID){
    plot <- plot + geom_line(data=dplyr::filter(df_fun, fun==id), aes(x, values, color = fun))
  }
  plot <- plot + 
          geom_point(data=data, aes(x=dose, y=value, color=ID)) +
          ylab("Arcsinh ratio\nover unstim signal with DMSO") +
          xlab("Dose") +
          theme(legend.position = "none",
                panel.background = element_rect(fill = NA, color = NA),
                plot.background = element_rect(fill = NA, color = NA),
                axis.title.x = element_text(size = 5),
                axis.title.y = element_text(size = 5),
                axis.text.x = element_text(size = 5),
                axis.text.y = element_text(size = 5),
                axis.line.x = element_line(),
                axis.line.y = element_line())
  
  return(plot)
}
```

**plot_median_sigmoid : **Function creating one plot for a median model

```{r}
plot_median_sigmoid <- function(target_feature, target_drug, model_list=hand.log10_1.median.model){
  # Selecting a specific model
  target_model <- subset(model_list,
                      feature == target_feature & drug == target_drug)
  
  # Setting the dose values to their pseudo log transform
  data <- AllPenDoseresponse %>%
                    dplyr::mutate(dose = log10_1_dose,
                                  ID = as.factor(ID)) %>%
                    dplyr::filter(is.finite(dose),
                                  feature == target_feature,
                                  drug == target_drug) %>%
                    dplyr::select(ID, dose, value)

  # Dataframe containing the function values on [min(dose), max(dose)]
  X = seq(min(data$dose)-0.1, max(data$dose)+0.1, length.out=100)
  df_fun <- data.frame(x=X)
  values <- c()
  constant <-median(data[data$ID==1,]$value)
  for (x in X){
    values <- c(values, sigmoid_function(x, target_model$b, target_model$c, target_model$d, target_model$e))
  }
  df_fun <- cbind(df_fun, values)
  
  # Plot
  plot <- ggplot() +
    geom_boxplot(data=data, mapping=aes(x=dose, y=value, group=dose)) + 
    geom_line(data=df_fun, aes(x, values)) +
    ylab("Arcsinh ratio\nover unstim signal with DMSO") +
    xlab("Dose") +
    theme(panel.background = element_rect(fill = NA, color = NA),
          plot.background = element_rect(fill = NA, color = NA),
          axis.title.x = element_text(size = 5),
          axis.title.y = element_text(size = 5),
          axis.text.x = element_text(size = 5),
          axis.text.y = element_text(size = 5),
          axis.line.x = element_line(),
          axis.line.y = element_line())
  
  return(plot)
}
```

Plotting the sigmoids of the drug on the chosen features versus the normal behavior of the OOL feature in order to see if the trends are actually opposites (or colinear) and that the chosen functions fit the data (the plots are accessible in the folder /Plots/Drug sigmoids vs OOL features)

```{r}
# Time to labor of interest (will plot the derivative at this point)
TTL <- mean(-79, -81, -81, -70)
  
for (target_drug in unique(AllPenDoseresponse$drug)){
  plots <- c()
  for (target_feature in names(OOL_features)){
    ### PLOT THE MEDIAN SIGMOID
    if (target_feature %in% AllPenDoseresponse$feature){
      plots[[length(plots)+1]] <- plot_median_sigmoid(target_feature, target_drug)
    }else{
      plots[[length(plots)+1]] <- ggplot() + theme_void()
    }
    
    ### PLOT THE ASSOCIATED OOL FEATURE
    # Getting the coefficients and class of the model
    coefs <- df_models[df_models$feature == target_feature,]$model[[1]][[1]]
    
    # building the predictions
    intercept <- coefs[['(Intercept)']]
    if (length(coefs) == 3){ # quadratic model
      a <- coefs[['DOS2']]
      b <- coefs[['DOS']]
      y_pred <- intercept + b * DOS + a * DOS^2
      y_deriv <- (2*a*TTL + b)*(DOS - TTL) + (intercept + b * TTL + a * TTL^2)
    }
    else{ # length(coefs) == 2, linear model
      slope <- coefs[['DOS']]
      y_pred <- intercept + slope * DOS
      y_deriv <- slope*(DOS - TTL) + (intercept + slope * TTL)
    }
     
    df <- data.frame("x" = DOS, "y" = OOL_data[, target_feature], "y_pred" = y_pred, "y_deriv" = y_deriv)
    pval <- curve.classification[curve.classification$cytof == target_feature,]$pval
    
    # Plot
    plot <- ggplot(df, aes(x = x, y = y)) +
        geom_point(fill = "white", shape=1, color="grey", size = 0.8, na.rm = TRUE) +
        geom_line(aes(y = y_pred), color = "darkgreen") +
        geom_line(aes(y = y_deriv), linetype = "dashed", color = "red", linewidth = 0.7) +
        geom_vline(xintercept = TTL, linetype = "dashed", color = "red", linewidth = 0.7) +
        ggtitle(paste(target_feature, pval, sep=",\np = ")) +
        ylab("Arcsinh ratio\nover unstim signal") +
        xlab("DOS") +
        theme(plot.title = element_text(size = 6),
              panel.background = element_rect(fill = NA, color = NA),
              plot.background = element_rect(fill = NA, color = NA),
              axis.title.x = element_text(size = 5),
              axis.title.y = element_text(size = 5),
              axis.text.x = element_text(size = 5),
              axis.text.y = element_text(size = 5),
              axis.line.x = element_line(),
              axis.line.y = element_line())
      
    # Adding plot to the list of plots
    plots[[length(plots)+1]] <- plot
    
    ### PLOT THE INDIVIDUAL SIGMOID
    if (target_feature %in% AllPenDoseresponse$feature){
      plots[[length(plots)+1]] <- plot_individual_sigmoids(target_feature, target_drug)
    }else{
      plots[[length(plots)+1]] <- ggplot() + theme_void()
    }
  }

  # Saving the plots
  pdf(paste(plot_path, "/", target_drug, "_on_", feature_choice,".pdf", sep = ""), width=6, height=8)
  for (i in 0:floor(length(plots)/12)){
    grid.arrange(grobs = plots[(12*i+1):min(c(length(plots),(12*i+12)))], nrow = 4, ncol = 3)
  }
  dev.off()
}
```

### Global visualization : heatmap

```{r}
# Function to plot the pheatmap of the final drug effect
plot_pheatmap <- function(title, drug.final.effect.dataframe, clustering_rows, clustering_cols, dendro=FALSE){
  breaksList <- seq(-1, 1, length.out = 100)
  my_colors <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(length(breaksList))
  
  # Preparing the data
  data <- as.matrix(drug.final.effect.dataframe[, -1])
  rownames(data) <- drug.final.effect.dataframe$population
  data[is.na(data)] <- 0
  # data[data > 1] <- 1
  # data[data < -1] <- -1
  
  # Reorganizing rows and columns
  row_order <- order.dendrogram(as.dendrogram(clustering_rows))
  col_order <- order.dendrogram(as.dendrogram(clustering_cols))
  data <- data[row_order, col_order]
  
  # Plot
  pheatmap(data, 
           color = my_colors,
           breaks = breaksList,
           na_color = "grey",
           cluster_rows = dendro, 
           cluster_cols = dendro,
           main = title,
           cellwidth = 10, 
           cellheight = 10,
           legend_breaks = c(-1, 0, 1),
           legend_labels = c("Drug effect colinear\nto normal pregnancy",
                             "Missing Value\nor\nNot significant",
                             "Drug effect opposite\nto normal pregnancy")
           )
}
```

Saving the heat maps for a chosen set of thresholds.

```{r}
# Parameters for the heat map scores
TTL <- mean(-79, -81, -81, -70)
normal.behavior.pval.threshold <- 1.
normal.behavior.slope.threshold <- 0.
list.ref.clustering.drug <- list("ID_median" = "Chlorthalidone", 
                                 "ID_1" = "Methylpredonisolone",
                                 "ID_2" = "Progesterone",
                                 "ID_3" = "Methylpredonisolone",
                                 "ID_4" = "Methylpredonisolone")
list.ref.clustering.c_k <- list("ID_median" = 4,
                                 "ID_1" = 4,
                                 "ID_2" = 4,
                                 "ID_3" = 4,
                                 "ID_4" = 4)

# Plotting all the heat maps
for (centroid in names(drug.effect.tensors)){
  # Building the clustering of reference for all the heatmaps
  ref_data <- create.drug.effect.data.frame(list.ref.clustering.drug[[centroid]],
                                            list.ref.clustering.c_k[[centroid]],
                                            centroid,
                                            normal.behavior.pval.threshold, 
                                            normal.behavior.slope.threshold, 
                                            TTL)
  data <- as.matrix(ref_data[, -1])
  rownames(data) <- ref_data$population
  data[is.na(data)] <- 0
  clustering_rows <- hclust(dist(data))
  clustering_cols <- hclust(dist(t(data)))
  
  # Creating the name of the file
  file.path = paste(plot_path, "/Drug effect (", ifelse(centroid=="ID_median", "median effect", paste0("patient ",sub(".*_", "", centroid))), ") heatmaps TTL=",TTL, ".pdf", sep="")
  
  # Creating the plots and saving them
  pdf(file.path, width = 12, height = 6)
  for (target_drug in unique(AllPenDoseresponse$drug)){
    for (c_k in seq(length(unique(AllPenDoseresponse$dose))-1)){
      plot_pheatmap(paste0(target_drug, " Dose ",10^(c_k-1)), 
                    create.drug.effect.data.frame(target_drug,
                                                  c_k,
                                                  centroid,
                                                  normal.behavior.pval.threshold, 
                                                  normal.behavior.slope.threshold, 
                                                  TTL),
                    clustering_rows,
                    clustering_cols,
                    dendro=FALSE)
    }
  }
  dev.off()
}
```