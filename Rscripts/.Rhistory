listr <- as.data.frame(listr) %>%
pivot_longer(cols = c("Lasso.1se","Ridge.Regression","ElasticNet","Adaptive.Lasso","Random.Forest"),
names_to = "model", values_to = "speamanr")
# Find the p-value threshold with the highest Spearman's correlation score
best_forest_threshold <- listr[listr$model=="Random.Forest",]$pval_threshold[which.max(listr[listr$model=="Random.Forest",]$speamanr)]
best_lasso_threshold <- listr[listr$model=="Lasso.1se",]$pval_threshold[which.max(listr[listr$model=="Lasso.1se",]$speamanr)]
best_EN_threshold <- listr[listr$model=="ElasticNet",]$pval_threshold[which.max(listr[listr$model=="ElasticNet",]$speamanr)]
best_ridge_threshold <- listr[listr$model=="Ridge.Regression",]$pval_threshold[which.max(listr[listr$model=="Ridge.Regression",]$speamanr)]
best_alasso_threshold <- listr[listr$model=="Adaptive.Lasso",]$pval_threshold[which.max(listr[listr$model=="Adaptive.Lasso",]$speamanr)]
# Plot
p <- ggplot(listr, aes(x = pval_threshold, y = speamanr, color = model)) +
geom_line() +
geom_segment(x = best_forest_threshold, xend = best_forest_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_lasso_threshold, xend = best_lasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_ridge_threshold, xend = best_ridge_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_EN_threshold, xend = best_EN_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_alasso_threshold, xend = best_alasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
labs(x = "p-value Threshold", y = "Spearman's correlation") +
ggtitle("Spearman's Correlation Scores by Model") +
theme_minimal() +
annotate("text", x = best_forest_threshold + 0.04, y = max(listr$best_r_score)+0.01, label = best_forest_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_lasso_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_lasso_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_EN_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_EN_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_ridge_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_ridge_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_alasso_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_alasso_threshold, color = "black", size = 3, vjust = -1)
# Saving plot
pdf(paste0(plot_path, "/Optimization of pvalue filtering.pdf"), height=5, width=7)
p
dev.off()
# listr
load(paste0(out_path, "/Pvalue threshold optimization.rda"))
# Reshaping listr for plotting
listr <- as.data.frame(listr) %>%
pivot_longer(cols = c("Lasso.1se","Ridge.Regression","ElasticNet","Adaptive.Lasso","Random.Forest"),
names_to = "model", values_to = "speamanr")
# Find the p-value threshold with the highest Spearman's correlation score
best_forest_threshold <- listr[listr$model=="Random.Forest",]$pval_threshold[which.max(listr[listr$model=="Random.Forest",]$speamanr)]
best_lasso_threshold <- listr[listr$model=="Lasso.1se",]$pval_threshold[which.max(listr[listr$model=="Lasso.1se",]$speamanr)]
best_EN_threshold <- listr[listr$model=="ElasticNet",]$pval_threshold[which.max(listr[listr$model=="ElasticNet",]$speamanr)]
best_ridge_threshold <- listr[listr$model=="Ridge.Regression",]$pval_threshold[which.max(listr[listr$model=="Ridge.Regression",]$speamanr)]
best_alasso_threshold <- listr[listr$model=="Adaptive.Lasso",]$pval_threshold[which.max(listr[listr$model=="Adaptive.Lasso",]$speamanr)]
# Plot
p <- ggplot(listr, aes(x = pval_threshold, y = speamanr, color = model)) +
geom_line() +
geom_segment(x = best_forest_threshold, xend = best_forest_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_lasso_threshold, xend = best_lasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_ridge_threshold, xend = best_ridge_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_EN_threshold, xend = best_EN_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_alasso_threshold, xend = best_alasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
labs(x = "p-value Threshold", y = "Spearman's correlation") +
ggtitle("Spearman's Correlation Scores by Model") +
theme_minimal() +
annotate("text", x = best_forest_threshold + 0.04, y = max(listr$best_r_score)+0.01, label = best_forest_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_alasso_threshold + 0.045, y = max(listr$best_r_score)+0.015, label = best_alasso_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_ridge_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_ridge_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_lasso_threshold , y = max(listr$best_r_score)+0.01, label = best_lasso_threshold, color = "black", size = 3, vjust = -1) +
annotate("text", x = best_EN_threshold, y = max(listr$best_r_score)+0.015, label = best_EN_threshold, color = "black", size = 3, vjust = -1)
# Saving plot
pdf(paste0(plot_path, "/Optimization of pvalue filtering.pdf"), height=5, width=7)
p
dev.off()
# listr
load(paste0(out_path, "/Pvalue threshold optimization.rda"))
# Reshaping listr for plotting
listr <- as.data.frame(listr) %>%
pivot_longer(cols = c("Lasso.1se","Ridge.Regression","ElasticNet","Adaptive.Lasso","Random.Forest"),
names_to = "model", values_to = "speamanr")
# Find the p-value threshold with the highest Spearman's correlation score
best_forest_threshold <- listr[listr$model=="Random.Forest",]$pval_threshold[which.max(listr[listr$model=="Random.Forest",]$speamanr)]
best_lasso_threshold <- listr[listr$model=="Lasso.1se",]$pval_threshold[which.max(listr[listr$model=="Lasso.1se",]$speamanr)]
best_EN_threshold <- listr[listr$model=="ElasticNet",]$pval_threshold[which.max(listr[listr$model=="ElasticNet",]$speamanr)]
best_ridge_threshold <- listr[listr$model=="Ridge.Regression",]$pval_threshold[which.max(listr[listr$model=="Ridge.Regression",]$speamanr)]
best_alasso_threshold <- listr[listr$model=="Adaptive.Lasso",]$pval_threshold[which.max(listr[listr$model=="Adaptive.Lasso",]$speamanr)]
# Plot
p <- ggplot(listr, aes(x = pval_threshold, y = speamanr, color = model)) +
geom_line() +
geom_segment(x = best_forest_threshold, xend = best_forest_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_lasso_threshold, xend = best_lasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_ridge_threshold, xend = best_ridge_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_EN_threshold, xend = best_EN_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_alasso_threshold, xend = best_alasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
labs(x = "p-value Threshold", y = "Spearman's correlation") +
ggtitle("Spearman's Correlation Scores by Model") +
theme_minimal() +
annotate("text", x = best_forest_threshold + 0.045, y = max(listr$best_r_score)+0.015, label = best_forest_threshold, size = 3, vjust = -1) +
annotate("text", x = best_alasso_threshold + 0.04, y = max(listr$best_r_score)+0.01, label = best_alasso_threshold, size = 3, vjust = -1) +
annotate("text", x = best_ridge_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_ridge_threshold, size = 3, vjust = -1) +
annotate("text", x = best_lasso_threshold , y = max(listr$best_r_score)+0.01, label = best_lasso_threshold, size = 3, vjust = -1) +
annotate("text", x = best_EN_threshold, y = max(listr$best_r_score)+0.015, label = best_EN_threshold, size = 3, vjust = -1)
# Saving plot
pdf(paste0(plot_path, "/Optimization of pvalue filtering.pdf"), height=5, width=7)
p
dev.off()
# listr
load(paste0(out_path, "/Pvalue threshold optimization.rda"))
# Reshaping listr for plotting
listr <- as.data.frame(listr) %>%
pivot_longer(cols = c("Lasso.1se","Ridge.Regression","ElasticNet","Adaptive.Lasso","Random.Forest"),
names_to = "model", values_to = "speamanr")
# Find the p-value threshold with the highest Spearman's correlation score
best_forest_threshold <- listr[listr$model=="Random.Forest",]$pval_threshold[which.max(listr[listr$model=="Random.Forest",]$speamanr)]
best_lasso_threshold <- listr[listr$model=="Lasso.1se",]$pval_threshold[which.max(listr[listr$model=="Lasso.1se",]$speamanr)]
best_EN_threshold <- listr[listr$model=="ElasticNet",]$pval_threshold[which.max(listr[listr$model=="ElasticNet",]$speamanr)]
best_ridge_threshold <- listr[listr$model=="Ridge.Regression",]$pval_threshold[which.max(listr[listr$model=="Ridge.Regression",]$speamanr)]
best_alasso_threshold <- listr[listr$model=="Adaptive.Lasso",]$pval_threshold[which.max(listr[listr$model=="Adaptive.Lasso",]$speamanr)]
# Plot
p <- ggplot(listr, aes(x = pval_threshold, y = speamanr, color = model)) +
geom_line() +
geom_segment(x = best_forest_threshold, xend = best_forest_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_lasso_threshold, xend = best_lasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_ridge_threshold, xend = best_ridge_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_EN_threshold, xend = best_EN_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
geom_segment(x = best_alasso_threshold, xend = best_alasso_threshold, y = 0., yend=max(listr$best_r_score)+0.01, linetype = "dashed") +
labs(x = "p-value Threshold", y = "Spearman's correlation") +
ggtitle("Spearman's Correlation Scores by Model") +
theme_minimal() +
annotate("text", x = best_forest_threshold + 0.045, y = max(listr$best_r_score)+0.015, label = best_forest_threshold, size = 3, vjust = -1) +
annotate("text", x = best_alasso_threshold + 0.04, y = max(listr$best_r_score)+0.01, label = best_alasso_threshold, size = 3, vjust = -1) +
annotate("text", x = best_ridge_threshold + 0.05, y = max(listr$best_r_score)+0.02, label = best_ridge_threshold, size = 3, vjust = -1) +
annotate("text", x = best_lasso_threshold , y = max(listr$best_r_score)+0.01, label = best_lasso_threshold, size = 3, vjust = -1) +
annotate("text", x = best_EN_threshold + 0.01, y = max(listr$best_r_score)+0.01, label = best_EN_threshold, size = 3, vjust = -1)
# Saving plot
pdf(paste0(plot_path, "/Optimization of pvalue filtering.pdf"), height=5, width=7)
p
dev.off()
# xxx parameter
parm=list()
parm$scale='Patient'
parm$a=0.5
npt=length(unique(Id))
parm$pval_threshold=1
# Adaptive.Lasso without EGA
parm$pval_threshold=0.01875
parm$predict.model="Lasso.1se"
# with EGA
# parm$pval_threshold=1e-14
# parm$predict.model="Lasso.1se"
# parm$predict.model="ElasticNet"
# Opening backend-configuration
cl <- makeSOCKcluster(detectCores())
registerDoSNOW(cl)
# Getting models and predictions
prdC=foreach(i=seq(npt),.packages = c("dplyr", "tibble")) %dopar% xxx(data.matrix(CYTOF), Yh, Id, i, parm, predicting.simulated.data)
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
setwd(paste0(my_path,"/Rscripts"))
OOL_path=paste0(my_path,"/Onset of Labor data")
drug_assay_path=paste0(my_path,"/Drug assay data")
out_path=paste0(drug_assay_path, "/Drug effect tensors")
plot_path=paste0(my_path, "/Plots/Drug effect tensors")
if(!file.exists(out_path)){dir.create(out_path, recursive=TRUE)}
if(!file.exists(plot_path)){dir.create(plot_path, recursive=TRUE)}
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(gridExtra)
library(grid)
# MedianDoseresponse
load(paste0(drug_assay_path, "/Preprocessed Data/median pen dose response with scales.rda"))
# AllPenDoseresponse
load(paste0(drug_assay_path, "/Preprocessed Data/all pen dose response with scales.rda"))
# hand.log10_1.median.model
load(paste0(drug_assay_path,"/Sigmoid functions/log10_1 hand median models.rda"))
# hand.log10_1.individual.model
load(paste0(drug_assay_path,"/Sigmoid functions/log10_1 hand individual models.rda"))
# hand.log10_1.model
hand.log10_1.model <- rbind(hand.log10_1.individual.model, hand.log10_1.median.model)
# Removing the datapoints that are post partum
OOL_data <- read.csv(paste0(OOL_path, "/Preprocessed Data/immunome_noEGA_DOS_pen_OOL.csv"), row.names = 1) %>%
filter(DOS <= 0)
# Getting the samples where DOS is between -94 and -74 to get a local distribution of the values around -84 days
local_OOL_data <- OOL_data %>% filter((DOS <= -74) & (DOS >= -94))
# drug.effect.tensors
load(paste0(out_path, "/drug effect tensors.rda"))
# clusters
load(paste0(OOL_path, "/Patients clustering/Cluster 53 OOL patients around 4 drug assay patients.rda"))
# Keeping a copy of OOL_data
original.OOL_data <- OOL_data
# Removing DOS from OOL_data since already stored
OOL_data <- dplyr::select(OOL_data, -DOS)
# Timepoints
DOS <- original.OOL_data$DOS
simulate.sample.data.under.all.drugs <- function(sample_ID, c_k, centroid_id="median"){
# Getting the specific tensor to apply
tensor <- drug.effect.tensors[[paste0("ID_", centroid_id)]][[c_k]] %>% t %>% as.data.frame()
# Getting the data from the sample
patient_data <- OOL_data[sample_ID,]
# Extending the tensor to have the same columns as patient_data
extended_tensor=cbind(tensor,
data.frame(matrix(0,
nrow=1,
ncol=length(setdiff(colnames(patient_data), colnames(tensor))),
dimnames=list(NULL, setdiff(colnames(patient_data), colnames(tensor))))))
# Joining patient_data and tensor
patient_and_tensor=rbind(patient_data, extended_tensor)
# Simulating each drug effect on the sample
for (drug in rownames(patient_and_tensor)){
if (drug != sample_ID){
patient_and_tensor[drug,] <- patient_and_tensor[sample_ID,] + patient_and_tensor[drug,]
}
}
# Removing original sample data
simulated_data <- patient_and_tensor[!(rownames(patient_and_tensor) %in% c(sample_ID)),]
# Adding the information about the tensor applied
simulated_data <- cbind(data.frame(row.names = rownames(simulated_data),
centroid = rep(centroid_id, length(rownames(simulated_data))),
dose = rep(10^(c_k-1), length(rownames(simulated_data))),
sampleID = rep(sample_ID, length(rownames(simulated_data)))),
simulated_data) %>%
rownames_to_column("drug")
return(simulated_data)
}
# Progress bar
pb <- txtProgressBar(min = 0, max = 4*length(rownames(OOL_data)), style = 3)
i <- 0
# Applying simulate.sample.data.under.all.drugs to all the samples with all concentrations
individual.simulated.data <- c()
for (sample_ID in rownames(OOL_data)){
for (c_k in 1:4){
# Progress bar
setTxtProgressBar(pb, i)
# Extracting patient ID
patient_id <- gsub("P(\\d+)_.*", "\\1", sample_ID)
# Getting the centroid corresponding to the ID
centroid_id <- which(sapply(clusters, function(vec) patient_id %in% vec))
# Simulating new data
simulated.data <- simulate.sample.data.under.all.drugs(sample_ID, c_k, centroid_id)
# Aggregating the new simulated data
individual.simulated.data <- rbind(individual.simulated.data, simulated.data)
# Incremental for progress bar
i <- i+1
}
}
# Creating a new directory
if(!file.exists(paste0(OOL_path, "/Simulated Data"))){dir.create(paste0(OOL_path, "/Simulated Data"), recursive = TRUE)}
# Saving the simulated data
save(individual.simulated.data, file=paste0(OOL_path, "/Simulated Data/individual simulated data.rda"))
individual.simulated.data
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
my_path<-"/Users/jonasamar/Desktop/Drug-Assay-Study"
# Install required packages
install.packages(c("dplyr"
#"ggplot2",
#"tidyr",
#"tidyverse",
#"tidyselect",
#"reshape2",
#"viridis",
#"janitor",
#"utils",
#"tibble",
#"stringr",
#"readxl",
#"pheatmap",
#"RColorBrewer",
#"paletteer",
#"r2glmm",
#"sjstats",
#"broom",
#"doSNOW",
#"parallel",
#"matrixStats",
#"zoo",
#"ggVennDiagram",
#"stats",
#"Metrics",
#"missMDA",
#"FactoMineR",
#"gridExtra",
#"grid"
), dependencies = TRUE)
# List of required package names
packages_to_install <- c("dplyr"
#"ggplot2",
#"tidyr",
#"tidyverse",
#"tidyselect",
#"reshape2",
#"viridis",
#"janitor",
#"utils",
#"tibble",
#"stringr",
#"readxl",
#"pheatmap",
#"RColorBrewer",
#"paletteer",
#"r2glmm",
#"sjstats",
#"broom",
#"doSNOW",
#"parallel",
#"matrixStats",
#"zoo",
#"ggVennDiagram",
#"stats",
#"Metrics",
#"missMDA",
#"FactoMineR",
#"gridExtra",
#"grid"
)
# Unload loaded packages (if needed)
loaded_packages <- intersect(packages_to_install, search())
# List of required package names
packages_to_install <- c("dplyr"
#"ggplot2",
#"tidyr",
#"tidyverse",
#"tidyselect",
#"reshape2",
#"viridis",
#"janitor",
#"utils",
#"tibble",
#"stringr",
#"readxl",
#"pheatmap",
#"RColorBrewer",
#"paletteer",
#"r2glmm",
#"sjstats",
#"broom",
#"doSNOW",
#"parallel",
#"matrixStats",
#"zoo",
#"ggVennDiagram",
#"stats",
#"Metrics",
#"missMDA",
#"FactoMineR",
#"gridExtra",
#"grid"
)
# Unload loaded packages (if needed)
loaded_packages <- intersect(packages_to_install, search())
if (length(loaded_packages) > 0) {
detach(paste("package:", loaded_packages, sep = ""), unload = TRUE)
}
# Install required packages
install.packages(packages_to_install, dependencies = TRUE)
# List of required package names
packages_to_install <- c("dplyr"
#"ggplot2",
#"tidyr",
#"tidyverse",
#"tidyselect",
#"reshape2",
#"viridis",
#"janitor",
#"utils",
#"tibble",
#"stringr",
#"readxl",
#"pheatmap",
#"RColorBrewer",
#"paletteer",
#"r2glmm",
#"sjstats",
#"broom",
#"doSNOW",
#"parallel",
#"matrixStats",
#"zoo",
#"ggVennDiagram",
#"stats",
#"Metrics",
#"missMDA",
#"FactoMineR",
#"gridExtra",
#"grid"
)
# Unload loaded packages (if needed)
loaded_packages <- intersect(packages_to_install, search())
if (length(loaded_packages) > 0) {
detach(paste("package:", loaded_packages, sep = ""), unload = TRUE)
}
# Install required packages
install.packages(packages_to_install, dependencies = TRUE)
install.packages(packages_to_install, dependencies = TRUE)
install.packages(packages_to_install, dependencies = TRUE)
install.packages("pacman")
pacman::p_load(ggplot2, tidyr, dplyr)
pacman::p_load(ggplot2, tidyr, dplyr, librarian)
pacman::p_load(c("ggplot2", "tidyr", "dplyr", "librarian"))
install.packages("pacman")
pacman::p_load(dplyr,
ggplot2,
tidyr,
tidyverse,
tidyselect,
reshape2,
viridis,
janitor,
utils,
tibble,
stringr,
readxl,
pheatmap,
RColorBrewer,
paletteer,
r2glmm,
sjstats,
broom,
doSNOW,
parallel,
matrixStats,
zoo,
ggVennDiagram,
stats,
Metrics,
missMDA,
FactoMineR,
gridExtra,
grid)
detach("package:broom", unload = TRUE)
detach("package:sjstats", unload = TRUE)
library(pacman)
detach("package:pacman", unload = TRUE)
detach("package:dplyr", unload = TRUE)
remove.packages("dplyr")
remove.packages("pacman")
remove.packages("ggplot2")
remove.packages("ggVennDiagram")
remove.packages("tidyr")
remove.packages("tidyverse")
remove.packages("tidyselect")
remove.packages("reshape2")
remove.packages("viridis")
remove.packages("viridisLite")
remove.packages("janitor")
remove.packages("tibble")
remove.packages("stringr")
remove.packages("readxl")
remove.packages("pheatmap")
remove.packages("RColorBrewer")
remove.packages("paletteer")
remove.packages("r2glmm")
remove.packages("sjstats")
remove.packages("broom")
remove.packages("doSNOW")
remove.packages("matrixStats")
remove.packages("zoo")
remove.packages("Metrics")
remove.packages("missMDA")
remove.packages("FactoMineR")
remove.packages("gridExtra")
install.packages("pacman")
install.packages("pacman")
pacman::p_load(dplyr,
ggplot2,
tidyr,
tidyverse,
tidyselect,
reshape2,
viridis,
janitor,
utils,
tibble,
stringr,
readxl,
pheatmap,
RColorBrewer,
paletteer,
r2glmm,
sjstats,
broom,
doSNOW,
parallel,
matrixStats,
zoo,
ggVennDiagram,
stats,
Metrics,
missMDA,
FactoMineR,
gridExtra,
grid)
pacman::p_load(dplyr,
ggplot2,
tidyr,
tidyverse,
tidyselect,
reshape2,
viridis,
janitor,
utils,
tibble,
stringr,
readxl,
pheatmap,
RColorBrewer,
paletteer,
r2glmm,
sjstats,
broom,
doSNOW,
parallel,
matrixStats,
zoo,
ggVennDiagram,
stats,
Metrics,
missMDA,
gridExtra,
grid)
library(gridExtra)
library(kbjbh)
library(FactoMineR)
